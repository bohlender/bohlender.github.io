<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SMT on bohlender.pro</title>
    <link>https://bohlender.pro/tags/smt/</link>
    <description>Recent content in SMT on bohlender.pro</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <managingEditor>contact@bohlender.pro (Dimitri Bohlender)</managingEditor>
    <webMaster>contact@bohlender.pro (Dimitri Bohlender)</webMaster>
    <copyright>Â© Dimitri Bohlender</copyright>
    <lastBuildDate>Sat, 22 Jan 2022 15:06:54 +0100</lastBuildDate><atom:link href="https://bohlender.pro/tags/smt/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Solving the &#34;Seven Segment Search&#34; Puzzle with Z3</title>
      <link>https://bohlender.pro/blog/aoc-seven-segment-search-with-z3/</link>
      <pubDate>Sat, 22 Jan 2022 15:06:54 +0100</pubDate>
      <author>contact@bohlender.pro (Dimitri Bohlender)</author>
      <guid>https://bohlender.pro/blog/aoc-seven-segment-search-with-z3/</guid>
      <description>&lt;p&gt;This week I stumbled upon &lt;a href=&#34;https://www.reddit.com/r/adventofcode/comments/rbwnh5/2021_day_8_can_it_be_solved_as_a_constraint/&#34;&gt;someone wondering&lt;/a&gt; whether the &lt;strong&gt;second part&lt;/strong&gt; of the recent &lt;a href=&#34;https://adventofcode.com/2021/day/8&#34;&gt;Advent of Code puzzle &amp;ldquo;Seven Segment Search&amp;rdquo;&lt;/a&gt; can be expressed as a constraint satisfaction problem.
As attested by the replies: yes, it can.
However, I think the question deserves a more extensive discussion than just a few comments in a thread.
This post tries to provide a more instructive answer and raise awareness for some of the tradeoffs or solver misuses some solutions put up with.&lt;/p&gt;
&lt;p&gt;I assume that the reader is familiar with mathematical notation and&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;just struggles to express the posed problem in a formal, declarative way, &lt;em&gt;or&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;is interested in seeing how the &lt;a href=&#34;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&#34;&gt;SMT&lt;/a&gt; solver &lt;a href=&#34;https://github.com/Z3Prover/z3/&#34;&gt;Z3&lt;/a&gt; can be used to express and solve the problem in several logics.
It takes only few steps to get from a quantifier-laden high-level formulation to what is effectively &lt;a href=&#34;https://en.wikipedia.org/wiki/Propositional_logic&#34;&gt;propositional logic&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Solving a Logic Synthesis Puzzle via SAT/SMT</title>
      <link>https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/</link>
      <pubDate>Sat, 30 Nov 2019 22:54:10 +0100</pubDate>
      <author>contact@bohlender.pro (Dimitri Bohlender)</author>
      <guid>https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/</guid>
      <description>&lt;p&gt;A few weeks ago, I was asked the following riddle:
&lt;q&gt;Design a &lt;a href=&#34;https://en.wikipedia.org/wiki/Logic_gate&#34;&gt;logic circuit&lt;/a&gt; with three inputs and three outputs, such that the outputs are the inverted inputs. You may use arbitrary many AND and OR gates, but at most two NOT gates&lt;/q&gt;.
Although the characterisation of this problem as an &lt;a href=&#34;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&#34;&gt;SMT&lt;/a&gt; instance is straightforward, I found it necessary to reduce it to &lt;a href=&#34;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem&#34;&gt;SAT&lt;/a&gt; and incorporate further assumptions to achieve reasonable performance.&lt;/p&gt;
&lt;p&gt;This post illustrates said process, ranging from the original idea to a standard formulation of SAT-based logic synthesis to a problem-specific and more constrained instance.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SMT-based Reasoning About the Fast Inverse Square Root</title>
      <link>https://bohlender.pro/blog/smt-based-optimisation-of-fast-inverse-square-root/</link>
      <pubDate>Thu, 12 Sep 2019 09:31:28 +0200</pubDate>
      <author>contact@bohlender.pro (Dimitri Bohlender)</author>
      <guid>https://bohlender.pro/blog/smt-based-optimisation-of-fast-inverse-square-root/</guid>
      <description>&lt;p&gt;While there is a &lt;a href=&#34;https://web.archive.org/web/20160308091758/http://www.daxia.com/bibis/upload/406Fast_Inverse_Square_Root.pdf&#34;&gt;mathematical explanation&lt;/a&gt; for the choice of &lt;code&gt;0x5F3759DF&lt;/code&gt; in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fast_inverse_square_root&#34;&gt;famous bit-level hack&lt;/a&gt; for approximating the multiplicative inverse of the square root of a 32-bit floating-point number, it is not immediately clear to what extent the reasoning is really applicable in the context of machine data types and their peculiarities.
This post illustrates how this, and related aspects, can be investigated with &lt;a href=&#34;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&#34;&gt;SMT&lt;/a&gt;-based reasoning about the actual implementation.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
