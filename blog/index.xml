<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dimitri Bohlender</title>
    <link>https://bohlender.github.io/blog/</link>
    <description>Thoughts on formal methods, computer science, art &amp; society</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <copyright>Â© Dimitri Bohlender</copyright>
    <lastBuildDate>Wed, 21 Aug 2019 17:23:49 +0200</lastBuildDate>
    <atom:link href="https://bohlender.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Playing Hard Mastermind Games with a SAT-based AI</title>
      <link>https://bohlender.github.io/blog/playing-hard-mastermind-games-with-a-sat-based-ai/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      <dc:creator>Dimitri Bohlender</dc:creator>
      <category>sat</category>
      <category>ai</category>
      <category>puzzle</category>
      <guid>https://bohlender.github.io/blog/playing-hard-mastermind-games-with-a-sat-based-ai/</guid>
      <description>&lt;p&gt;Back in the day, &lt;a href=&#34;https://en.wikipedia.org/wiki/Mastermind_(board_game)&#34;&gt;Mastermind&lt;/a&gt; was a popular two player code-breaking game, and many &lt;a href=&#34;https://en.wikipedia.org/wiki/Mastermind_(board_game)#Variations&#34;&gt;variations thereof&lt;/a&gt; still exist as both standalone games and puzzles within other games.
Although it is difficult for a human player to make &lt;em&gt;optimal guesses&lt;/em&gt; of the secret code, or at least guesses that do not conflict with the provided clues, the setting is usually simple enough for an AI to find such candidates via explicit exploration of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Game_tree&#34;&gt;game tree&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, such approaches becomes unfeasible when the number of possibilities for secret codes grows into the millions.
This post illustrates the problem with standard approaches, and how finding consistent candidates can be approached with &lt;a href=&#34;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem&#34;&gt;SAT&lt;/a&gt; solving &amp;ndash; yielding an AI that can handle orders-of-magnitude harder Mastermind instances.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Solving a Logic Synthesis Puzzle via SAT/SMT</title>
      <link>https://bohlender.github.io/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/</link>
      <pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate>
      <dc:creator>Dimitri Bohlender</dc:creator>
      <category>sat</category>
      <category>smt</category>
      <category>logic synthesis</category>
      <category>puzzle</category>
      <guid>https://bohlender.github.io/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/</guid>
      <description>&lt;p&gt;A few weeks ago, I was asked the following riddle:
&lt;q&gt;Design a &lt;a href=&#34;https://en.wikipedia.org/wiki/Logic_gate&#34;&gt;logic circuit&lt;/a&gt; with three inputs and three outputs, such that the outputs are the inverted inputs. You may use arbitrary many AND and OR gates, but at most two NOT gates&lt;/q&gt;.
Although the characterisation of this problem as an &lt;a href=&#34;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&#34;&gt;SMT&lt;/a&gt; instance is straightforward, I found it necessary to reduce it to &lt;a href=&#34;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem&#34;&gt;SAT&lt;/a&gt; and incorporate further assumptions to achieve reasonable performance.&lt;/p&gt;
&lt;p&gt;This post illustrates said process, ranging from the original idea to a standard formulation of SAT-based logic synthesis to a problem-specific and more constrained instance.&lt;/p&gt;</description>
    </item>
    <item>
      <title>SMT-based Reasoning About the Fast Inverse Square Root</title>
      <link>https://bohlender.github.io/blog/smt-based-optimisation-of-fast-inverse-square-root/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      <dc:creator>Dimitri Bohlender</dc:creator>
      <category>smt</category>
      <category>smt-lib</category>
      <category>software verification</category>
      <guid>https://bohlender.github.io/blog/smt-based-optimisation-of-fast-inverse-square-root/</guid>
      <description>&lt;p&gt;While there is a &lt;a href=&#34;https://web.archive.org/web/20160308091758/http://www.daxia.com/bibis/upload/406Fast_Inverse_Square_Root.pdf&#34;&gt;mathematical explanation&lt;/a&gt; for the choice of &lt;code&gt;0x5F3759DF&lt;/code&gt; in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fast_inverse_square_root&#34;&gt;famous bit-level hack&lt;/a&gt; for approximating the multiplicative inverse of the square root of a 32-bit floating-point number, it is not immediately clear to what extent the reasoning is really applicable in the context of machine data types and their peculiarities.
This post illustrates how this, and related aspects, can be investigated with &lt;a href=&#34;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&#34;&gt;SMT&lt;/a&gt;-based reasoning about the actual implementation.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>