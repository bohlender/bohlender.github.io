<!DOCTYPE html>
<html lang="en-gb">
    <head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/perfundo.with-icons.min.css">
	<link rel="stylesheet" href="/katex/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ">
<script defer src="/katex/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"></script>
<script defer src="/katex/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"
        onload="renderMathInElement(document.body, {
        delimiters: [
            {left: `$$`, right: `$$`, display: true},
            {left: `$`, right: `$`, display: false},
        ]
    });"></script>
	<link rel="alternate" type="application/rss+xml" href="https://bohlender.pro/blog/index.xml" title="bohlender.pro" />
	
	


<meta property="og:title" content="Solving a Logic Synthesis Puzzle via SAT/SMT" />
<meta property="og:description" content="A few weeks ago, I was asked the following riddle:
Design a logic circuit with three inputs and three outputs, such that the outputs are the inverted inputs. You may use arbitrary many AND and OR gates, but at most two NOT gates.
Although the characterisation of this problem as an SMT instance is straightforward, I found it necessary to reduce it to SAT and incorporate further assumptions to achieve reasonable performance.
This post illustrates said process, ranging from the original idea to a standard formulation of SAT-based logic synthesis to a problem-specific and more constrained instance." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/" />

<meta property="og:image" content="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gfx/full_adder.svg" />

<meta property="og:image" content="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gfx/puzzle.svg" />

<meta property="og:image" content="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gfx/schematic_v1.svg" />

<meta property="og:image" content="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gfx/schematic_v2.svg" />
<meta property="article:published_time" content="2019-12-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-11-30T22:54:10+01:00" />
	
	<title>Solving a Logic Synthesis Puzzle via SAT/SMT | bohlender.pro</title>
</head>
    <body class="blog">
        <header>
	<nav>
		<label for="show-menu" class="show-menu">
			<img class="icon" src="/gfx/fa-icons.svg#bars" alt="Toggle menu"/>
		</label>
		<input type="checkbox" id="show-menu" role="button" aria-pressed="true">
		<ul class="dropdown">
			<li><a href="/">Home</a></li>
			<li><a href="/cv/">CV</a></li>
			<li><a href="/projects/">Projects</a></li>
			<li><a href="/blog/">Blog</a></li>
			<li><a href="/photography/">Photography</a></li>
		</ul>
	</nav>
</header>
        <div class="container">
        <div class="content">
<div class="banner">
	
    
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="443" height="350" viewBox="0 0 443 350">
        <image xlink:href="/gfx/cup-rss.png" width="443" height="350"/>
        <a href="https://bohlender.pro/blog/index.xml" target="_top">
            <circle style="fill: transparent" cx="187" cy="165" r="110"/>
        </a>
    </svg>
</div>
<div class="notepad-wrapper">
	
	<div class="notepad">
		<main>
		<article>
			<header>
				
				<h1>Solving a Logic Synthesis Puzzle via SAT/SMT</h1>
				<div class="metadata">
    <time datetime="2019-12-12">December 12, 2019</time>
    <ul>
        <li><a class="tag-block" href="/tags/sat">SAT</a></li>
        <li><a class="tag-block" href="/tags/smt">SMT</a></li>
        <li><a class="tag-block" href="/tags/logic-synthesis">Logic Synthesis</a></li>
        <li><a class="tag-block" href="/tags/puzzle">Puzzle</a></li>
    </ul>
</div>
			</header>
			<p>A few weeks ago, I was asked the following riddle:
<q>Design a <a href="https://en.wikipedia.org/wiki/Logic_gate">logic circuit</a> with three inputs and three outputs, such that the outputs are the inverted inputs. You may use arbitrary many AND and OR gates, but at most two NOT gates</q>.
Although the characterisation of this problem as an <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a> instance is straightforward, I found it necessary to reduce it to <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a> and incorporate further assumptions to achieve reasonable performance.</p>
<p>This post illustrates said process, ranging from the original idea to a standard formulation of SAT-based logic synthesis to a problem-specific and more constrained instance.</p>
<h2 id="introduction"><a href="#introduction" class="hanchor" ariaLabel="Anchor">Introduction</a> </h2>
<p><a href="https://en.wikipedia.org/wiki/Logic_synthesis">Logic synthesis</a> is the process of turning an abstract circuit description into a concrete design in terms of logic gates.
In the context of our riddle, the abstract description can be formalised as a set of goal functions which the circuit must realise:
$$
\begin{aligned}
g_0(x_0,x_1,x_2) &=\neg x_0\\
g_1(x_0,x_1,x_2)&=\neg x_1\\
g_2(x_0,x_1,x_2)&=\neg x_2
\end{aligned}
$$
where $x_0,x_1,x_2$ are the circuit&rsquo;s Boolean inputs.</p>
<p>Instead of thinking of a solution ourselves, we want to characterise the problem in terms of constraints whose solution can be interpreted as a solution to the riddle.
To this end, we intend the constraints to describe a generic circuit that is parametrised by the <em>functions</em> that its gates realise, and the <em>connections</em> between these gates.</p>

<aside >
    <p>
    Without loss of generality, we restrict ourselves to gates with two inputs.
Gates with larger <a href="https://en.wikipedia.org/wiki/Fan-in">fan-in</a> can be constructed from these.
    </p>
</aside>
<p>The following schematic illustrates one choice of connections (solid) from the many potential wirings (dashed) for an example with only one output $g_0$ and one gate $f_3$.</p>







<figure class="figure-outer" id="generic-1-gate-circuit">
    <figure class="figure-inner">
        <img src="gfx/schematic_v1.svg" width="180"/> 
            <figcaption>
                Generic 1-gate circuit
            </figcaption>
    </figure>
    
</figure>
<p>If $g_0$ were $x_0 \wedge x_1$, choosing the highlighted wiring and $f_3$ as AND would be a desirable logic synthesis result.
Conceptually we want to guarantee something along these lines:
$$
\tag{1}\forall x_0,x_1,x_2\ldotp g_0(x_0, x_1, x_2)=\mathit{circuit}(x_0,x_1,x_2)
$$
where $\mathit{circuit}$ is defined by the choice of $f_3$ and the wiring.
Here, $f_3$ and the wiring are the parameters which we, or a constraint solver, can tweak to establish the validity of $(1)$.</p>

<aside >
    <p>
    As in the post on the <a href="/blog/smt-based-optimisation-of-fast-inverse-square-root">inverse square root hack</a>, logic synthesis can be understood as a <strong>parameter synthesis</strong> problem, too.
We are searching for a choice of parameters (gates and wiring) that make the system (circuit) compliant with some property for every input.
    </p>
</aside>
<p>So what kind of wiring should we allow?
Considering the generic circuit with one gate, $g_0$ can only be connected to the inputs $x_0, x_1, x_2$ or the gate&rsquo;s output $x_3$.
Depending on which inputs $f_3$ is connected to, its output $x_3$ will be given by $f_3(x_0,x_1), f_3(x_0,x_2)$ or $f_3(x_1,x_2)$.
Note that it is sufficient to consider the input combinations $f_3(x_j, x_k)$ for $1\leq j &lt; k &lt; 3$ since $f_3$ is unconstrained (yet) and can represent any binary operator on Booleans.
In other words, if there were a solution with $x_3=f_3(x_2,x_1)$, we would also find it with $x_3=f_3(x_1, x_2)$ but the interpretation of $f_3$ <q>mirrored</q>.</p>
<p>Allowing an arbitrary number of gates and arbitrary connections right from the start will result in an unnecessarily huge search space.
Instead, we restrict ourselves to a fixed number of gates which we can increase incrementally if the current number of gates turns out to be insufficient to synthesise the goal function $g_0$.
Without loss of generality, the inputs of a new gate $f_{n+1}$ may be connected to preceding gates (and inputs) $x_0,\dots,x_n$ but not the other way around, e.g. $x_4$ may not be an input of $f_3$.
This was the ad-hoc approach <a href="https://lukas-boersma.com/">my colleague</a> and I figured should work, so I started implementing it.</p>
<h2 id="smt-based-logic-synthesis"><a href="#smt-based-logic-synthesis" class="hanchor" ariaLabel="Anchor">SMT-based Logic Synthesis</a> </h2>
<p>Looking at the schematic from the introduction, characterising the logic synthesis problem boils down to:</p>
<ol>
<li>formulating how the outputs $g_i$ may be connected to the gates $x_0, \dots, x_n$, and</li>
<li>formulating how the gates may be interconnected.</li>
</ol>
<p>To denote that a gate $g_i$ is connected to $x_j$ we use a variable $g_{i,j}$.
Similarly, we introduce variables $c_{i, j, k}$ to encode that $x_j$ is the first input of $f_i$, and $x_k$ the second one.
With this in mind, reconsidering the wiring from our schematic, only $g_{0,3}$ and $c_{3,0,1}$ should be $\mathit{true}$.</p>







<figure class="figure-outer" id="connection-variables">
    <figure class="figure-inner">
        <img src="gfx/schematic_v2.svg" width="240"/> 
            <figcaption>
                Connection variables
            </figcaption>
    </figure>
    
</figure>
<p>For the simple case of $n=1$ inner gates, a circuit can be synthesised if (and only if) the following is satisfiable:
$$
\tag{2}
\begin{aligned}
\forall x_0,x_1,x_2~ \exists x_3\ldotp &~ (g_0(x_0,x_1,x_2) = x_0\\
\vee &~ g_0(x_0,x_1,x_2)= x_1\\
\vee &~ g_0(x_0,x_1,x_2)= x_2\\
\vee &~ \textcolor{a6e22e}{g_0}(x_0,x_1,x_2)= \textcolor{a6e22e}{x_3})\\
\wedge &~ (x_3=\textcolor{f92672}{f_3(x_0,x_1)}\\
\vee &~ x_3 = f_3(x_0,x_2)\\
\vee &~ x_3 = f_3(x_1,x_2))
\end{aligned}
$$</p>
<p>Here, the first part requires $g_0$ to be connected to at least one $x_i$, and the second part requires $f_3$ to be connected to some combination of inputs.
In contrast to $(1)$, we now express the circuit&rsquo;s overall semantics $\mathit{circuit}(x_0, x_1, x_2)$ in terms of the functions realised by its gates.
Increasing either the number of outputs or gates will merely add further conjuncts in the same vein.</p>
<p>However, this characterisation does not yet make use of the variables $g_{i,j}$ and $c_{i,j,k}$ to encode the chosen wiring.
To bind the intended semantics to these variables, we let the variables imply the corresponding options and require at least one of them to be $\mathit{true}$.</p>

<aside >
    
    <p>We do not explicitly require $g_0$ to be connected to exactly one $x_i$.
Although we can add this constraint it is not necessary.
For example, if the solver finds a satisfying assignment with both $g_{0,4}$ and $g_{0,5}$ set to $\mathit{true}$ then the values of $x_4$ and $x_5$ coincide for all inputs and $g_0$ can be connected to any.</p>
<p>This hints at redundancy and realisability of the circuit with fewer gates.
Most of the time the connection variables $g_{i,j}$ of an output $g_i$ cannot be $\mathit{true}$ at the same time.
The same reasoning applies to the connection variables $c_{i,j,k}$ of gates.</p>

    
</aside>
<p>This yields an <a href="https://en.wikipedia.org/wiki/Equisatisfiability">equisatisfiable</a> constraint:</p>
$$
\tag{3}
\begin{aligned}
\forall x_0,x_1,x_2~ \exists x_3\ldotp &~ (g_{0,0}\rightarrow g_0(x_0,x_1,x_2) = x_0)\\
\wedge &~ (g_{0,1}\rightarrow g_0(x_0,x_1,x_2)= x_1)\\
\wedge &~ (g_{0,2}\rightarrow g_0(x_0,x_1,x_2)= x_2)\\
\wedge &~ (\textcolor{a6e22e}{g_{0,3}}\rightarrow g_0(x_0,x_1,x_2)= x_3)\\
\wedge &~ (g_{0,0} \vee g_{0,1} \vee g_{0,2} \vee \textcolor{a6e22e}{g_{0,3}})\\
\wedge &~ (\textcolor{f92672}{c_{3,0,1}}\rightarrow x_3 = f_3(x_0,x_1))\\
\wedge &~ (c_{3,0,2}\rightarrow x_3 = f_3(x_0,x_2))\\
\wedge &~ (c_{3,1,2}\rightarrow x_3 = f_3(x_1,x_2))\\
\wedge &~ (\textcolor{f92672}{c_{3,0,1}} \vee c_{3,0,2} \vee c_{3,1,2})
\end{aligned}
$$
<p>If there is an interpretation that satisfies $(2)$, then it can be extended to an interpretation that satisfies $(3)$ by picking appropriate values for $g_{i,j}$ and $c_{i,j,k}$ and vice versa.</p>
<p>Conceptually, <strong>that&rsquo;s all there is to characterising a generic logic synthesis</strong> problem in <a href="https://en.wikipedia.org/wiki/First-order_logic">first-order logic</a>.
However, to solve the introductory riddle we still have to restrict the functions $f_i$ to AND, OR and at most two NOTs.</p>
<p>Restricting the $f_i$ to AND, OR and NOT amounts to constraining each $f_i$ to these operators' truth tables, i.e. also assert for each $f_i$ that
$$
\begin{aligned}
    &(\neg f_i(0,0) \wedge \neg f_i(0, 1) \wedge \neg f_i(1,0) \wedge f_i(1, 1))\\
    \vee~ & (\neg f_i(0,0) \wedge f_i(0, 1) \wedge f_i(1,0) \wedge f_i(1, 1))\\
    \vee~ & (f_i(0,0) \wedge \neg f_i(0, 1) = f_i(1,0) \wedge \neg f_i(1, 1))\\
\end{aligned}
$$</p>

<aside >
    <p>
    We use $0$ and $1$ instead of $\mathit{false}$ and $\mathit{true}$ to improve readability.
Of course the constants must be truth values and not integers.
    </p>
</aside>
<p>Here, the first line is only satisfied by an AND, the second line is only satisfied by an OR, and the last line is only satisfied by a NOT on the gate&rsquo;s first or second input.
This characterisation of NOT is needed since all of our $f_i$ have two parameters.</p>
<p>Having restricted the functions to the allowed gates, we can also limit the number of NOTs by means of <a href="http://theory.stanford.edu/~nikolaj/programmingz3.html#sec-cardinality-constraints">cardinality constraints</a>:
$$
\begin{aligned}
    & (f_3(0,0) \wedge \neg f_3(0, 1) = f_3(1,0) \wedge \neg f_3(1, 1))\\
    +~& (f_4(0,0) \wedge \neg f_4(0, 1) = f_4(1,0) \wedge \neg f_4(1, 1))\\
    &~ \vdots\\
    +~& (f_n(0,0) \wedge \neg f_n(0, 1) = f_n(1,0) \wedge \neg f_n(1, 1))\\
    \leq~& 2
\end{aligned}
$$
essentially constraining how many $f_i$ may be interpreted as NOTs.</p>
<h3 id="implementation"><a href="#implementation" class="hanchor" ariaLabel="Anchor">Implementation</a> </h3>
<p>Using the Python bindings of <a href="https://github.com/Z3Prover/z3/">Z3</a>, an implementation of this approach for arbitrary numbers of inputs, outputs and inner gates spans only <a href="gen_smt2.py">few lines of code</a>.</p>
<p>Functions over argument lists allow for an easy specification of the wanted outputs:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">65
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#75715e"># Original puzzle (possible with 19 gates)</span>
g0 <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> inputs: Not(inputs[<span style="color:#ae81ff">0</span>])
g1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> inputs: Not(inputs[<span style="color:#ae81ff">1</span>])
g2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> inputs: Not(inputs[<span style="color:#ae81ff">2</span>])
outputs <span style="color:#f92672">=</span> [g0, g1, g2]</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py">gen_smt2.py</a>
    </figcaption>
</figure>
<p>Providing the number of inputs and inner gates to consider, we can create lists of the corresponding variables $x_i$ and their uninterpreted functions $f_i:\mathbb{B}^2\rightarrow\mathbb{B}$ as follows:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#75715e"># Create variables (and values for inputs) for each x_i</span>
x <span style="color:#f92672">=</span> [Bool(<span style="color:#e6db74">&#34;x</span><span style="color:#e6db74">{:d}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(gate_idx)) <span style="color:#66d9ef">for</span> gate_idx <span style="color:#f92672">in</span> range(num_inputs <span style="color:#f92672">+</span> num_inner_gates)]

<span style="color:#75715e"># Create functions f:B^2--&gt;B realised by the inner gates</span>
f_sig <span style="color:#f92672">=</span> [BoolSort()]<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>
f <span style="color:#f92672">=</span> [Function(<span style="color:#e6db74">&#34;f</span><span style="color:#e6db74">{:d}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(gate_idx), f_sig) <span style="color:#66d9ef">for</span> gate_idx <span style="color:#f92672">in</span> range(num_inputs, len(x))]</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py">gen_smt2.py</a>
    </figcaption>
</figure>
<p>The characterisation of possible output connections strongly follows the scheme shown in $(3)$.
We create variables $g_{i,j}$ for the potential connection of $g_i$ and each $x_j$, and let them imply that $g_i(\mathit{inputs})=x_j$.
It is also asserted that at least one $g_{i,j}$ for each $g_i$ must be $\mathit{true}$:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    




    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">output_connections</span>(num_inputs, x, outputs):
    asserts <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> output_idx <span style="color:#f92672">in</span> range(len(outputs)):
        conn_vars <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> gate_idx <span style="color:#f92672">in</span> range(len(x)):
            conn_var <span style="color:#f92672">=</span> Bool(<span style="color:#e6db74">&#34;g_</span><span style="color:#e6db74">{:d}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">{:d}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(output_idx, gate_idx))
            conn_vars<span style="color:#f92672">.</span>append(conn_var)
            asserts<span style="color:#f92672">.</span>append(Implies(conn_var, outputs[output_idx](x[:num_inputs]) <span style="color:#f92672">==</span> x[gate_idx]))
        asserts<span style="color:#f92672">.</span>append(Or(conn_vars))
    <span style="color:#66d9ef">return</span> asserts</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py">gen_smt2.py</a>
    </figcaption>
</figure>
<p>The characterisation of possible gate connections is very similar.
The enumeration of relevant input combinations can be achieved comfortably via <a href="https://docs.python.org/3.8/library/itertools.html?itertools.combinations#itertools.combinations"><code>itertools.combinations</code></a>:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    




    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gate_connections</span>(num_inputs, x, f):
    asserts <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> gate_idx <span style="color:#f92672">in</span> range(num_inputs, len(x)):
        print(<span style="color:#e6db74">&#34;Encoding gate </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(gate_idx))
        conn_vars <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> in1_idx, in2_idx <span style="color:#f92672">in</span> combinations(range(gate_idx), <span style="color:#ae81ff">2</span>):
            conn_var <span style="color:#f92672">=</span> Bool(<span style="color:#e6db74">&#34;c_</span><span style="color:#e6db74">{:d}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">{:d}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">{:d}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(gate_idx, in1_idx, in2_idx))
            conn_vars<span style="color:#f92672">.</span>append(conn_var)
            asserts<span style="color:#f92672">.</span>append(Implies(conn_var, x[gate_idx] <span style="color:#f92672">==</span> f[gate_idx <span style="color:#f92672">-</span> num_inputs](x[in1_idx], x[in2_idx])))
        asserts<span style="color:#f92672">.</span>append(Or(conn_vars))
    <span style="color:#66d9ef">return</span> asserts</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py">gen_smt2.py</a>
    </figcaption>
</figure>
<p>Finally, the code for the riddle-specific additional constraints of $f_i$ closely resembles the constraints shown in the end of the previous section:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    




    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f_constraints</span>(f):
    asserts <span style="color:#f92672">=</span> []
    is_and <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> gate: And(Not(gate(<span style="color:#66d9ef">False</span>, <span style="color:#66d9ef">False</span>)), Not(gate(<span style="color:#66d9ef">False</span>, <span style="color:#66d9ef">True</span>)), Not(gate(<span style="color:#66d9ef">True</span>, <span style="color:#66d9ef">False</span>)), gate(<span style="color:#66d9ef">True</span>, <span style="color:#66d9ef">True</span>))
    is_or <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> gate: And(Not(gate(<span style="color:#66d9ef">False</span>, <span style="color:#66d9ef">False</span>)), gate(<span style="color:#66d9ef">False</span>, <span style="color:#66d9ef">True</span>), gate(<span style="color:#66d9ef">True</span>, <span style="color:#66d9ef">False</span>), gate(<span style="color:#66d9ef">True</span>, <span style="color:#66d9ef">True</span>))
    is_not <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> gate: And(gate(<span style="color:#66d9ef">False</span>, <span style="color:#66d9ef">False</span>), gate(<span style="color:#66d9ef">False</span>, <span style="color:#66d9ef">True</span>) <span style="color:#f92672">!=</span> gate(<span style="color:#66d9ef">True</span>, <span style="color:#66d9ef">False</span>), Not(gate(<span style="color:#66d9ef">True</span>, <span style="color:#66d9ef">True</span>)))

    <span style="color:#66d9ef">for</span> gate <span style="color:#f92672">in</span> f:
        gate_filters <span style="color:#f92672">=</span> [is_and(gate), is_or(gate), is_not(gate)]
        asserts<span style="color:#f92672">.</span>append(Or(gate_filters))
    <span style="color:#66d9ef">if</span> len(f) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
        asserts<span style="color:#f92672">.</span>append(AtMost([is_not(gate) <span style="color:#66d9ef">for</span> gate <span style="color:#f92672">in</span> f] <span style="color:#f92672">+</span> [<span style="color:#ae81ff">2</span>]))
    <span style="color:#66d9ef">return</span> asserts</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py">gen_smt2.py</a>
    </figcaption>
</figure>
<p>All that remains is simplifying these constraints and acquiring their <a href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf">SMT-LIB representation</a> &ndash; the common exchange format for SMT solvers:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">s <span style="color:#f92672">=</span> Solver()
constraints <span style="color:#f92672">=</span> output_connections(num_inputs, x, outputs) <span style="color:#f92672">+</span> gate_connections(num_inputs, x, f) <span style="color:#f92672">+</span> f_constraints(f)
simplified <span style="color:#f92672">=</span> And([simplify(assrt) <span style="color:#66d9ef">for</span> assrt <span style="color:#f92672">in</span> constraints])
quantified <span style="color:#f92672">=</span> ForAll(x[:num_inputs], Exists(x[num_inputs:], simplified) <span style="color:#66d9ef">if</span> num_inner_gates <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> simplified)
s<span style="color:#f92672">.</span>add(quantified)
<span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span>to_smt2() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;(get-model)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span></code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py">gen_smt2.py</a>
    </figcaption>
</figure>

<aside >
    <p>
    Note that we could easily let Z3 solve the instance right away via <code>s.check()</code>.
I just prefer benchmarking the once generated SMT instances instead of regenerating them in every run.
    </p>
</aside>
<p>The resulting characterisation works great for synthesis of smaller circuits, such as a full adder built from just ANDs, ORs and at most two NOTs:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#75715e"># Full adder example (impossible with 8 restricted gates; possible with 9)</span>
sum <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> inputs: Xor(Xor(inputs[<span style="color:#ae81ff">0</span>], inputs[<span style="color:#ae81ff">1</span>]), inputs[<span style="color:#ae81ff">2</span>])
carry <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> inputs: Or(And(inputs[<span style="color:#ae81ff">0</span>], inputs[<span style="color:#ae81ff">1</span>]), And(Xor(inputs[<span style="color:#ae81ff">0</span>], inputs[<span style="color:#ae81ff">1</span>]), inputs[<span style="color:#ae81ff">2</span>]))
outputs <span style="color:#f92672">=</span> [sum, carry]</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py">gen_smt2.py</a>
    </figcaption>
</figure>
<p>Feel free to experiment with <a href="gen_smt2.py">the implementation</a>, feed the generated instances into SMT solvers, and interpret the found solutions before continuing with the SAT-based approach.
I&rsquo;ve attached the full adder synthesis <a href="full_adder.smt2">SMT instance</a> to this post, so you don&rsquo;t have run the generator.
The solution I get from Z3 describes the following circuit:</p>







<figure class="figure-outer" id="visualisation-of-synthesised-full-adder">
    <figure class="figure-inner">
        <img src="gfx/full_adder.svg" width="350"/> 
            <figcaption>
                Visualisation of synthesised full adder
            </figcaption>
    </figure>
    
</figure>
<p>Unfortunately, the quantifiers, uninterpreted functions and cardinality constraints render the instance that characterises the introductory puzzle too difficult to be solved within several days.
Therefore, in the next section, we reduce the characterisation to <a href="https://en.wikipedia.org/wiki/Propositional_calculus">propositional logic</a>, trading off the complexity of our constraints against a larger instance, and end up with a standard approach for SAT-based logic synthesis.
While the SMT-based synthesis of a full adder may take a few seconds, the <a href="full_adder.cnf">corresponding SAT instance</a> will be <a href="full_adder.log">solvable in milliseconds</a>.</p>
<h2 id="sat-based-logic-synthesis"><a href="#sat-based-logic-synthesis" class="hanchor" ariaLabel="Anchor">SAT-based Logic Synthesis</a> </h2>
<p>To make our problem approachable via SAT solving, we must reformulate the constraints to be free of quantifiers and uninterpreted functions.
The cardinality constraints are less of a problem since (i) many SAT solvers support them, and (ii) Z3 can also reduce them to propositional logic for us.</p>

<aside >
    <p>
    Strictly speaking, non-logical symbols like <q>=</q> are not part of propositional logic either but are easily reduced to it.
As with the cardinality constraints, Z3 does this automatically for us.
    </p>
</aside>
<h3 id="eliminating-the-existential-quantifier"><a href="#eliminating-the-existential-quantifier" class="hanchor" ariaLabel="Anchor">Eliminating the Existential Quantifier</a> </h3>
<p>The first step of this reduction is understanding the $\exists$-quantified gate outputs as functions of the $\forall$-quantified circuit inputs.
Clearly, the gates' outputs depend on the current inputs.
With this in mind, our example constraint $(3)$ can be rewritten as follows:</p>
$$
\tag{4}
\begin{aligned}
\forall x_0,x_1,x_2\ldotp &~ (g_{0,0}\rightarrow g_0(x_0,x_1,x_2) = x_0)\\
\wedge &~ (g_{0,1}\rightarrow g_0(x_0,x_1,x_2)= x_1)\\
\wedge &~ (g_{0,2}\rightarrow g_0(x_0,x_1,x_2)= x_2)\\
\wedge &~ (g_{0,3}\rightarrow g_0(x_0,x_1,x_2)= x_3(x_0,x_1,x_2))\\
\wedge &~ (g_{0,0} \vee g_{0,1} \vee g_{0,2} \vee g_{0,3})\\
\wedge &~ (c_{3,0,1}\rightarrow x_3(x_0,x_1,x_2) = f_3(x_0,x_1))\\
\wedge &~ (c_{3,0,2}\rightarrow x_3(x_0,x_1,x_2) = f_3(x_0,x_2))\\
\wedge &~ (c_{3,1,2}\rightarrow x_3(x_0,x_1,x_2) = f_3(x_1,x_2))\\
\wedge &~ (c_{3,0,1} \vee c_{3,0,2} \vee c_{3,1,2})
\end{aligned}
$$
<p>One detail that is easily overlooked is that the inner gates' inputs are not guaranteed to be constants, such as $x_0,x_1$ and $x_2$, but may be function evaluations.
For example, if we were to characterise a generic circuit with $n=2$ inner gates, the following clause would surface (among others):</p>
$$
\tag{5} c_{4,0,3} \rightarrow x_4(x_0,x_1,x_2) = f_4(x_0,x_3(x_0,x_1,x_2))
$$
<h3 id="eliminating-the-universal-quantifier"><a href="#eliminating-the-universal-quantifier" class="hanchor" ariaLabel="Anchor">Eliminating the Universal Quantifier</a> </h3>
<p>In next step we get rid of the $\forall$-quantifier.
Looking at how $\forall x$ is defined for a Boolean $x$
$$
\forall x\ldotp \varphi := \varphi[\mathit{true}/x] \wedge \varphi[\mathit{false}/x]
$$
it is easy to see that we can eliminate one variable at a time by cloning the expression $\varphi$ and substituting $x$ by $\mathit{true}$ in the first instance and by $\mathit{false}$ in the second one.
We effectively enumerate all the values the quantifier ranges over and conjunct the instantiated constraints.</p>

<aside >
    <p>
    Although every variable elimination doubles the number of constraints, and will clearly not scale to arbitrary numbers of inputs, it is fine for our purposes.
The puzzle features three inputs so this quantifier elimination only increases the characterisation by roughly $2^3$.
    </p>
</aside>
<p>By eliminating the $\forall$-quantifier in $(4)$ like this, we end up with
$$
\tag{6}
\begin{aligned}
&
\begin{aligned}
    (g_{0,0} \rightarrow&~ g_0(0,0,0) = 0)\\
    \wedge&~ g_0(0,0,1) = 0)\\
    \wedge&~ g_0(0,1,0) = 0)\\
    \wedge&~ g_0(0,1,1) = 0)\\
    \wedge&~ g_0(1,0,0) = 1)\\
    \wedge&~ g_0(1,0,1) = 1)\\
    \wedge&~ g_0(1,1,0) = 1)\\
    \wedge&~ g_0(1,1,1) = 1))\\
\end{aligned}\\
\wedge~ & (g_{0,1} \rightarrow~ \dots )\\
\wedge~ & (g_{0,2} \rightarrow~ \dots )\\
\wedge~ & (g_{1,2} \rightarrow~ \dots )\\
\wedge~ & (g_{0,0} \vee g_{0,1} \vee g_{0,2} \vee g_{0,3})\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(0,0,0) = f_3(0,0))\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(0,0,1) = f_3(0,0))\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(0,1,0) = f_3(0,1))\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(0,1,1) = f_3(0,1))\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(1,0,0) = f_3(1,0))\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(1,0,1) = f_3(1,0))\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(1,1,0) = f_3(1,1))\\
\wedge~ & (c_{3,0,1} \rightarrow~ x_3(1,1,1) = f_3(1,1))\\
\wedge~ & (c_{3,0,2} \rightarrow~ \dots )\\
\wedge~ & (c_{3,1,2} \rightarrow~ \dots )\\
\wedge~ &(c_{3,0,1} \vee c_{3,0,2} \vee c_{3,1,2})
\end{aligned}
$$
where we again use $0$ and $1$ to denote $\mathit{false}$ and $\mathit{true}$, respectively.
Note that we could as well have encoded the implications of $c_{3,0,1}$ in a single clause (like the implications of $g_{0,0}$).
However, the illustrated encoding will make the upcoming elimination of uninterpreted functions more readable.</p>
<p>Although likely clear, I want to stress that if we had a more complex clause like $(5)$, it would be expanded into the following clauses:</p>
$$
\begin{aligned}
    &~(c_{4,0,3} \rightarrow x_4(0,0,0) = f_4(0,x_3(0,0,0)))\\
    \wedge&~ (c_{4,0,3} \rightarrow x_4(0,0,1) = f_4(0,x_3(0,0,1)))\\
    \wedge&~ (c_{4,0,3} \rightarrow x_4(0,1,0) = f_4(0,x_3(0,1,0)))\\
    \wedge&~ (c_{4,0,3} \rightarrow x_4(0,1,1) = f_4(0,x_3(0,1,1)))\\
    \wedge&~ (c_{4,0,3} \rightarrow x_4(1,0,0) = f_4(1,x_3(1,0,0)))\\
    \wedge&~ (c_{4,0,3} \rightarrow x_4(1,0,1) = f_4(1,x_3(1,0,1)))\\
    \wedge&~ (c_{4,0,3} \rightarrow x_4(1,1,0) = f_4(1,x_3(1,1,0)))\\
    \wedge&~ (c_{4,0,3} \rightarrow x_4(1,1,1) = f_4(1,x_3(1,1,1)))
\end{aligned}
$$
<h3 id="eliminating-uninterpreted-functions"><a href="#eliminating-uninterpreted-functions" class="hanchor" ariaLabel="Anchor">Eliminating Uninterpreted Functions</a> </h3>
<p>The last step of the reduction is the elimination of the uninterpreted functions $f_i$ and the corresponding $x_i$.
Since we&rsquo;re dealing with functions over Booleans, we can simply introduce a variable for each entry of a function&rsquo;s truth table, and encode the semantics in terms of these entries.</p>

<aside >
    <p>
    Note that the goal functions $g_i$ are not uninterpreted but known and evaluated during construction of the constraints.
    </p>
</aside>
<p>For example, a gate $f_4:\mathbb{B}^2\rightarrow \mathbb{B}$ can be encoded by an assignment to the four variables
$$
f_{4,(0,0)}, f_{4,(0,1)}, f_{4,(1,0)}, f_{4,(1,1)}
$$
each of which represents an entry of $f_4$&rsquo;s truth table.
Similarly, a function $x_i:\mathbb{B}^3\rightarrow \mathbb{B}$ will be blasted into $2^3$ variables $x_{i,(0,0,0)}, \dots, x_{i,(1,1,1)}$ to refer to the value of $x_i$ for different inputs.</p>
<p>Since the elimination of all uninterpreted functions from $(6)$ would take too much space, I will illustrate the approach on a single but generic clause
$$
c_{i,j,k} \rightarrow x_i(0,0,0) = f_i(x_j(0,0,0),x_k(0,0,0))
$$</p>
<p>If $x_j$ and $x_k$ are picked as the inputs of $f_i$, this constraint requires $f_i$ to relate the truth values of these inputs with the gate&rsquo;s output $x_i$, for a given circuit input $(0,0,0)$.
To get rid of $f_i$ but express the same semantics with the new variables, we explicitly enumerate all $2^3$ possible combinations of input and output values of the gate, and require the corresponding $f_{i,(0,0)},\dots,f_{i,(1,1)}$ to be consistent with them:</p>
$$
\begin{aligned}
    &~ (c_{i,j,k} \wedge \neg x_{i,(0,0,0)} \wedge \neg x_{j,(0,0,0)} \wedge \neg x_{k,(0,0,0)} \rightarrow \neg f_{4,(0,0)})\\
    \wedge &~ (c_{i,j,k} \wedge \neg x_{i,(0,0,0)} \wedge \neg x_{j,(0,0,0)} \wedge x_{k,(0,0,0)} \rightarrow \neg f_{4,(0,1)})\\
    \wedge &~ (c_{i,j,k} \wedge \neg x_{i,(0,0,0)} \wedge x_{j,(0,0,0)} \wedge \neg x_{k,(0,0,0)} \rightarrow \neg f_{4,(1,0)})\\
    \wedge &~ (c_{i,j,k} \wedge \neg x_{i,(0,0,0)} \wedge x_{j,(0,0,0)} \wedge x_{k,(0,0,0)} \rightarrow \neg f_{4,(1,1)})\\
    \wedge &~ (c_{i,j,k} \wedge x_{i,(0,0,0)} \wedge \neg x_{j,(0,0,0)} \wedge \neg x_{k,(0,0,0)} \rightarrow f_{4,(0,0)})\\
    \wedge &~ (c_{i,j,k} \wedge x_{i,(0,0,0)} \wedge \neg x_{j,(0,0,0)} \wedge x_{k,(0,0,0)} \rightarrow f_{4,(0,1)})\\
    \wedge &~ (c_{i,j,k} \wedge x_{i,(0,0,0)} \wedge x_{j,(0,0,0)} \wedge \neg x_{k,(0,0,0)} \rightarrow f_{4,(1,0)})\\
    \wedge &~ (c_{i,j,k} \wedge x_{i,(0,0,0)} \wedge x_{j,(0,0,0)} \wedge x_{k,(0,0,0)} \rightarrow f_{4,(1,1)})\\
\end{aligned}
$$
<p>Applying this transformation to the clauses from $(6)$ leaves us with a SAT instance that is equivalent to a <a href="https://people.eecs.berkeley.edu/~alanmi/publications/2018/date18_exact.pdf">standard formulation</a> of SAT-based logic synthesis.</p>
<h3 id="implementation-1"><a href="#implementation-1" class="hanchor" ariaLabel="Anchor">Implementation</a> </h3>
<p>Since <a href="gen_sat.py">the implementation</a> is mostly a refinement of the SMT instance generator, I will only touch on some aspects and refer to the implementation for details.</p>
<p>The biggest difference to the SMT-based characterisation is that we introduced variables $x_{i,(0,0,0)},\dots,x_{i,(1,1,1)}$ and $f_{i,(0,0),\dots,f_{i,(1,1)}}$ to refer to the values of $x_i$ and $f_i$ for every possible input.
Accordingly, the implementation now uses lists of lists for indexing all the variants of $x_i$ and $f_i$:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#75715e"># Create variables (and values for inputs) for each x_i, given concrete inputs</span>
x <span style="color:#f92672">=</span> [[Bool(<span style="color:#e6db74">&#34;x</span><span style="color:#e6db74">{:d}{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(gate_idx, val)) <span style="color:#66d9ef">for</span> val <span style="color:#f92672">in</span> product(range(<span style="color:#ae81ff">2</span>), repeat<span style="color:#f92672">=</span>num_inputs)]
     <span style="color:#66d9ef">for</span> gate_idx <span style="color:#f92672">in</span> range(num_inputs <span style="color:#f92672">+</span> num_inner_gates)]
<span style="color:#75715e"># Replace variables for inputs by concrete values</span>
<span style="color:#66d9ef">for</span> input_idx <span style="color:#f92672">in</span> range(num_inputs):
    <span style="color:#66d9ef">for</span> idx, bits <span style="color:#f92672">in</span> enumerate(product(range(<span style="color:#ae81ff">2</span>), repeat<span style="color:#f92672">=</span>num_inputs)):
        x[input_idx][idx] <span style="color:#f92672">=</span> BoolVal(bits[input_idx])

<span style="color:#75715e"># Create functions f:B^2--&gt;B realised by the inner gates</span>
f <span style="color:#f92672">=</span> [[Bool(<span style="color:#e6db74">&#34;f</span><span style="color:#e6db74">{:d}{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(gate_idx, val)) <span style="color:#66d9ef">for</span> val <span style="color:#f92672">in</span> product(range(<span style="color:#ae81ff">2</span>), repeat<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)]
     <span style="color:#66d9ef">for</span> gate_idx <span style="color:#f92672">in</span> range(num_inputs, len(x))]</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_sat.py">gen_sat.py</a>
    </figcaption>
</figure>
<p>Due to this indexing of variables, the restriction of $f_i$ has to be adapted slightly too.
Instead of identifying a gate by its outputs for certain inputs, we now refer to each entry of the gate&rsquo;s truth table:</p>








    


    
    




    
    
        
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">is_and <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> gate: And(Not(gate[<span style="color:#ae81ff">0</span>]), Not(gate[<span style="color:#ae81ff">1</span>]), Not(gate[<span style="color:#ae81ff">2</span>]), gate[<span style="color:#ae81ff">3</span>])
is_or <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> gate: And(Not(gate[<span style="color:#ae81ff">0</span>]), gate[<span style="color:#ae81ff">1</span>], gate[<span style="color:#ae81ff">2</span>], gate[<span style="color:#ae81ff">3</span>])
is_not <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> gate: And(gate[<span style="color:#ae81ff">0</span>], Not(gate[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">==</span> gate[<span style="color:#ae81ff">2</span>], Not(gate[<span style="color:#ae81ff">3</span>]))</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_sat.py">gen_sat.py</a>
    </figcaption>
</figure>
<p>Besides the indexing, the implementation uses the very same reduction to SAT that has been sketched above, and maintains the general structure of the SMT-oriented implementation.
What needs mention though is how to export the constraints in the <a href="https://www.domagoj-babic.com/uploads/ResearchProjects/Spear/dimacs-cnf.pdf">DIMACS</a> exchange format used by virtually all SAT solvers:</p>








    


    
    




    
    
        
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">67
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">68
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">69
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">70
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">71
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">72
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">73
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">74
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">75
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">goal <span style="color:#f92672">=</span> Goal()
<span style="color:#66d9ef">for</span> assrt <span style="color:#f92672">in</span> output_connections(num_inputs, x, outputs) <span style="color:#f92672">+</span> gate_connections(num_inputs, x, f) <span style="color:#f92672">+</span> f_constraints(f):
    goal<span style="color:#f92672">.</span>add(simplify(assrt))

<span style="color:#75715e"># Reduce cardinality constraints; transform to CNF</span>
to_cnf <span style="color:#f92672">=</span> Then(Tactic(<span style="color:#e6db74">&#34;card2bv&#34;</span>), Tactic(<span style="color:#e6db74">&#34;tseitin-cnf&#34;</span>))
subgoals <span style="color:#f92672">=</span> to_cnf(goal)
<span style="color:#66d9ef">assert</span> len(subgoals) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Tactic should have resulted in a single goal&#34;</span>
<span style="color:#66d9ef">assert</span> <span style="color:#f92672">not</span> subgoals[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>inconsistent(), <span style="color:#e6db74">&#34;Found to be UNSAT during pre-processing&#34;</span>
<span style="color:#66d9ef">return</span> subgoals[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>dimacs() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span></code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_sat.py">gen_sat.py</a>
    </figcaption>
</figure>
<p>Z3 provides <a href="http://theory.stanford.edu/~nikolaj/programmingz3.html#sec-tactics">tactics</a> that can be applied to a set of constraints.
By applying <code>card2bv</code>, all occurring cardinality constraints will be reduced to propositional logic.
The subsequent <code>tseitin-cnf</code> tactic brings the resulting constraints into <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form</a> (CNF) &ndash; in fact they almost are in CNF already.
The resulting constraints can then be output in the DIMACS format.</p>
<p>Although a SAT-based characterisation is a lot larger than its SMT-based counterpart, it is less complex and is typically solved in orders-of-magnitude less time.
Feel free to experiment with <a href="gen_sat.py">the implementation</a>, or try to reconstruct the full adder circuit <a href="gfx/full_adder.svg">shown above</a> from the <a href="full_adder.cnf">generated SAT instance</a> and <a href="full_adder.log">the solution</a> found by a SAT solver.</p>
<p>Still, the constraint that restricts the number of NOTs seems to make the SAT instance that characterises the introductory puzzle hard to solve.
The next section proposes an additional assumption that is rather weak but sufficient to alleviate the combinatorial explosion, and make the constraints solvable in reasonable time.</p>
<h2 id="solving-the-puzzle"><a href="#solving-the-puzzle" class="hanchor" ariaLabel="Anchor">Solving the Puzzle</a> </h2>
<p>The constraints that we used so far did not make any assumptions that could disregard potential solutions to the puzzle, but merely formalised the provided information.
To make the combinatorial explosion more manageable, we will now incorporate an assumption that <em>likely</em> holds for the circuit, but may potentially disregard some solutions.</p>
<p>Our assumption is rather weak and concerns the connections of the outputs to the inner gates.
We assume that if there is a solution, it likely can be formulated so that the outputs are connected to the very last gates of the circuit.
In particular, each goal $g_i$ can certainly be computed independently, i.e. without referring to the value of an other output $g_j$.
We can enforce these connections by extending our <a href="gen_sat.py">generic SAT-based characterisation</a> with:</p>








    


    
    




    
    
        
    

    
    

    
    




    
        
    
    

    
        
    
    

    
        
    
    

<figure class="highlight-figure">
    <div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#75715e"># Connect outputs to last gates</span>
<span style="color:#66d9ef">if</span> output_idx <span style="color:#f92672">==</span> len(x) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> gate_idx:
    asserts<span style="color:#f92672">.</span>append(conn_var)</code></pre></td></tr></table>
</div>
</div>
    <figcaption>
        <a href="https://bohlender.pro/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_puzzle.py">gen_puzzle.py</a>
    </figcaption>
</figure>
<p>With these additional constraints, it took an old i5-4690 CPU <a href="puzzle.log">about 30min</a> to solve the <a href="puzzle.cnf">corresponding SAT instance</a> with <strong>19 inner gates</strong>.
The synthesised circuit looks as follows:</p>







<figure class="figure-outer" id="solution-to-puzzle">
    <figure class="figure-inner">
        <img src="gfx/puzzle.svg" width="500"/> 
            <figcaption>
                Solution to puzzle
            </figcaption>
    </figure>
    
</figure>
<p>Since we only allow gates with fan-in 2, here, the NOT2 denotes a NOT on the second input.</p>
<h2 id="do-try-this-at-home"><a href="#do-try-this-at-home" class="hanchor" ariaLabel="Anchor">Do Try This at Home!</a> </h2>
<p>Although the SAT-based characterisation of logic synthesis turns out to be <a href="https://people.eecs.berkeley.edu/~alanmi/publications/2018/date18_exact.pdf">common in practice</a> &ndash; especially without the artificial constraint on the number of gates &ndash; there is still room for improvement and experimentation.
Here are some ideas that you might want to explore on your own (easiest first):</p>
<ul>
<li>Instead of relying on an external solver to solve the generated constraints, use the API to invoke the check programmatically.</li>
<li>Does a solution to the riddle with less than 19 gates exist? Prove your hypothesis.</li>
<li>Automate the interpretation of the solutions found by a solver as logic circuits, and plot them via <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">DOT</a>.</li>
<li>Extend the characterisation to allow some composite gates.
For example, I found that the <a href="https://puzzling.stackexchange.com/questions/9438/invert-three-inputs-with-two-not-gates">expected solution</a> has circuitry to decide whether more than one (or more than two) inputs are $\mathit{true}$.
Requiring the synthesis to feature such blocks may speed up the synthesis of the puzzle&rsquo;s solution.</li>
<li>Instead of characterising the circuit for a fixed number of gates, devise an incremental variant of SMT-based or SAT-based synthesis which incorporates one additional gate at a time (and checks satisfiability).
It should be advantageous to have the solver reuse information established during checks with fewer gates.</li>
</ul>
<p>If you manage to solve the riddle without the domain-specific assumption, or have any ideas how to do this more efficiently with SAT/SMT solving, please let me know.
It might also be possible to solve this with the logic synthesis tools mentioned in <a href="https://people.eecs.berkeley.edu/~alanmi/publications/2018/date18_exact.pdf">the paper</a> that discusses the SAT-based encoding we ended up with.</p>
<hr style="margin-top: 2em">
<div class="links">

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/full_adder.cnf" class="button">full_adder.cnf</a>

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/full_adder.smt2" class="button">full_adder.smt2</a>

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/puzzle.cnf" class="button">puzzle.cnf</a>

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/full_adder.log" class="button">full_adder.log</a>

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_puzzle.py" class="button">gen_puzzle.py</a>

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_sat.py" class="button">gen_sat.py</a>

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/gen_smt2.py" class="button">gen_smt2.py</a>

    <a href="/blog/solving-a-logic-synthesis-puzzle-via-sat-smt/puzzle.log" class="button">puzzle.log</a>

</div>
		</article>
		</main>
	</div>
	
	<div class="notepad related-posts">
		<h1>Related Posts</h1>
		<hr>
		
			<article>
    <header>
        <h2><a href="https://bohlender.pro/blog/aoc-seven-segment-search-with-z3/">Solving the &#34;Seven Segment Search&#34; Puzzle with Z3</a></h2>
        <div class="metadata">
    <time datetime="2022-02-13">February 13, 2022</time>
    <ul>
        <li><a class="tag-block" href="/tags/smt">SMT</a></li>
        <li><a class="tag-block" href="/tags/puzzle">Puzzle</a></li>
        <li><a class="tag-block" href="/tags/advent-of-code">Advent of Code</a></li>
    </ul>
</div>
    </header><p>This week I stumbled upon <a href="https://www.reddit.com/r/adventofcode/comments/rbwnh5/2021_day_8_can_it_be_solved_as_a_constraint/">someone wondering</a> whether the <strong>second part</strong> of the recent <a href="https://adventofcode.com/2021/day/8">Advent of Code puzzle &ldquo;Seven Segment Search&rdquo;</a> can be expressed as a constraint satisfaction problem.
As attested by the replies: yes, it can.
However, I think the question deserves a more extensive discussion than just a few comments in a thread.
This post tries to provide a more instructive answer and raise awareness for the tradeoffs or solver misuses some solutions put up with.</p>
<p>I assume that the reader is familiar with mathematical notation and</p>
<ul>
<li>just struggles to express the posed problem in a formal, declarative way, <em>or</em></li>
<li>is interested in seeing how the <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a> solver <a href="https://github.com/Z3Prover/z3/">Z3</a> can be used to express and solve the problem in several logics.
It takes only few steps to get from a quantifier-laden high-level formulation to what is effectively <a href="https://en.wikipedia.org/wiki/Propositional_logic">propositional logic</a>.</li>
</ul>
	<a class="read-more" href="https://bohlender.pro/blog/aoc-seven-segment-search-with-z3/">
        &raquo; Read more
    </a>
</article>
		
			<article>
    <header>
        <h2><a href="https://bohlender.pro/blog/generating-crosswords-with-sat-smt/">Generating Crosswords via SAT/SMT</a></h2>
        <div class="metadata">
    <time datetime="2020-10-24">October 24, 2020</time>
    <ul>
        <li><a class="tag-block" href="/tags/sat">SAT</a></li>
        <li><a class="tag-block" href="/tags/puzzle">Puzzle</a></li>
    </ul>
</div>
    </header><p>Recently I got interested in designing personalised crosswords as a way to spice up photo book presents.
This made me realise how hard generating <q>high-quality</q> crosswords actually is.
Trying to create a crossword from a set of words &ndash; or a subset thereof &ndash; I checked out several tools but found all of them to be based on heuristics and yield rather sparse crosswords.</p>
<p>In line with the general theme of my previous posts, this one illustrates how we can leverage <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT solving</a> to solve this problem.
In contrast to related approaches, which assume a fixed grid structure and search for fitting words, we consider word placement as part of the problem and eventually end up with an integrated solution to generating crosswords of adjustable quality.</p>
	<a class="read-more" href="https://bohlender.pro/blog/generating-crosswords-with-sat-smt/">
        &raquo; Read more
    </a>
</article>
		
			<article>
    <header>
        <h2><a href="https://bohlender.pro/blog/playing-hard-mastermind-games-with-a-sat-based-ai/">Playing Hard Mastermind Games with a SAT-based AI</a></h2>
        <div class="metadata">
    <time datetime="2020-03-12">March 12, 2020</time>
    <ul>
        <li><a class="tag-block" href="/tags/sat">SAT</a></li>
        <li><a class="tag-block" href="/tags/ai">AI</a></li>
        <li><a class="tag-block" href="/tags/puzzle">Puzzle</a></li>
    </ul>
</div>
    </header><p>Back in the day, <a href="https://en.wikipedia.org/wiki/Mastermind_(board_game)">Mastermind</a> was a popular two player code-breaking game, and many <a href="https://en.wikipedia.org/wiki/Mastermind_(board_game)#Variations">variations thereof</a> still exist as both standalone games and puzzles within other games.
Although it is difficult for a human player to make <em>optimal guesses</em> of the secret code, or at least guesses that do not conflict with the provided clues, the setting is usually simple enough for an AI to find such candidates via explicit exploration of the <a href="https://en.wikipedia.org/wiki/Game_tree">game tree</a>.</p>
<p>However, such approaches become unfeasible when the number of possibilities for secret codes grows into the millions.
This post illustrates the problem with standard approaches, and how finding consistent candidates can be approached with <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a> solving &ndash; yielding an AI that can handle orders-of-magnitude harder Mastermind instances.</p>
	<a class="read-more" href="https://bohlender.pro/blog/playing-hard-mastermind-games-with-a-sat-based-ai/">
        &raquo; Read more
    </a>
</article>
		
	</div>
	
</div>

        </div>
        </div>
        <footer>
	<p>© Dimitri Bohlender</p>
	<p><a href="/legal">Legal Notice</a></p>
</footer>
    </body>
</html>
